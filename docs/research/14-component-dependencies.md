# 14. 組件依賴分析與開發路線

## 目標

識別：
1. **垂直組件**：有依賴關係，單獨無作用，必須按順序
2. **平行組件**：可同時開發，互相獨立但可加成
3. **互通點**：開發到什麼程度可以開始互通

---

## 組件依賴圖

```
                           ┌─────────────────────┐
                           │    CLAUDE.md        │
                           │  (全局規則基底)      │
                           └──────────┬──────────┘
                                      │ 讀取
          ┌───────────────────────────┼───────────────────────────┐
          │                           │                           │
          ▼                           ▼                           ▼
┌─────────────────┐         ┌─────────────────┐         ┌─────────────────┐
│     Agents      │         │     Hooks       │         │     Skills      │
│  (執行者定義)    │         │  (事件攔截器)    │         │  (知識模組)      │
└────────┬────────┘         └────────┬────────┘         └────────┬────────┘
         │                           │                           │
         │ 調用                       │ 觸發                       │ 調用
         ▼                           ▼                           ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                            Scripts Layer                                 │
│                         (腳本與工具函數)                                  │
└─────────────────────────────────────────────────────────────────────────┘
         │                           │                           │
         │ 讀寫                       │ 讀寫                       │ 讀寫
         ▼                           ▼                           ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         .vibe-engine/ Runtime                            │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐  │
│  │ config   │  │  tasks   │  │ memory   │  │   logs   │  │  audit   │  │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘  └──────────┘  │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 垂直依賴鏈（必須按順序）

### 鏈 1：基礎設施鏈

```
CLAUDE.md → Hooks (PreToolUse) → Runtime 目錄結構
   │              │                    │
   │              │                    └─ 沒有目錄，無法儲存狀態
   │              └─ 沒有 Hook，無法攔截操作
   └─ 沒有規則，Agent 無法知道該遵守什麼
```

**最小可行版本**：
1. `CLAUDE.md` - 基本規則（Router Not Executor, Safety First）
2. `hooks.json` - 空的 hooks 定義檔
3. `scripts/init-runtime.sh` - 創建 `.vibe-engine/` 目錄

---

### 鏈 2：任務執行鏈

```
Main Agent → Task Decomposition Skill → SubAgent 定義 → 執行
     │              │                        │
     │              │                        └─ 沒有 SubAgent，無法分派
     │              └─ 沒有分解能力，Main 只能自己做
     └─ 沒有 Main，沒有協調者
```

**最小可行版本**：
1. `agents/main-orchestrator.md` - 基本路由能力
2. `skills/task-decomposition/SKILL.md` - 簡單分解規則
3. `agents/developer.md` - 至少一個 SubAgent

---

### 鏈 3：狀態持久化鏈

```
任務執行 → Checkpoint 機制 → 恢復能力
    │            │              │
    │            │              └─ 沒有恢復，checkpoint 沒用
    │            └─ 沒有 checkpoint，無法恢復
    └─ 沒有執行，沒有狀態需要保存
```

**最小可行版本**：
1. 任務狀態結構 (`tasks/{id}/state.json`)
2. `scripts/create-checkpoint.sh`
3. `scripts/restore-checkpoint.sh`

---

## 平行組件（可同時開發）

```
┌─────────────────────────────────────────────────────────────────────────┐
│                          可平行開發的功能模組                             │
├─────────────────┬─────────────────┬─────────────────┬─────────────────┤
│   驗證模組       │    記憶模組      │   觀測模組       │   方法論模組    │
│                 │                 │                 │                 │
│ • 靜態分析      │ • 記憶儲存      │ • Token 計數    │ • Spec 生成     │
│ • 測試執行      │ • 記憶檢索      │ • 操作日誌      │ • 健康檢查      │
│ • LLM Judge    │ • 記憶注入      │ • 預算警報      │ • 熵指標        │
│                 │                 │                 │                 │
│ 輸出：驗證報告   │ 輸出：記憶項目   │ 輸出：使用報告   │ 輸出：Spec 檔案 │
└─────────────────┴─────────────────┴─────────────────┴─────────────────┘
          │                 │                 │                 │
          └─────────────────┴─────────────────┴─────────────────┘
                                    │
                                    ▼
                        ┌─────────────────────┐
                        │  .vibe-engine/       │
                        │  (共享 Runtime)      │
                        └─────────────────────┘
```

**關鍵**：這四個模組只要遵守共同的 Runtime 格式，就可以完全獨立開發。

---

## 互通點分析

### 互通點 1：任務狀態格式

```typescript
// .vibe-engine/tasks/{id}/state.json
interface TaskState {
  id: string;
  status: 'pending' | 'in_progress' | 'completed' | 'failed';
  created_at: string;
  updated_at: string;

  // 各模組可擴展的區塊
  verification?: VerificationResult;  // 驗證模組寫入
  memory_refs?: string[];             // 記憶模組寫入
  budget_usage?: BudgetUsage;         // 觀測模組寫入
  spec_ref?: string;                  // 方法論模組寫入
}
```

**互通效果**：
- 任務完成時，驗證模組可以自動執行驗證
- 任務失敗時，記憶模組可以記錄錯誤經驗
- 任務執行中，觀測模組可以追蹤預算

---

### 互通點 2：事件系統

```yaml
# 透過 Hook 事件互通
events:
  task_created:
    listeners:
      - memory: 檢索相關記憶
      - budget: 預估 token 消耗

  task_completed:
    listeners:
      - verification: 執行驗證
      - memory: 提取經驗
      - observability: 記錄統計

  verification_failed:
    listeners:
      - memory: 記錄失敗原因
      - methodology: 建議重構
```

**實作方式**：透過 PostToolUse hooks 觸發

---

### 互通點 3：Context 注入

```yaml
# SessionStart 時各模組注入 context
context_injection:
  memory_module:
    injects:
      - relevant_memories
      - past_errors
    location: system_prompt_prefix

  budget_module:
    injects:
      - remaining_budget
      - suggested_model
    location: system_prompt_suffix

  methodology_module:
    injects:
      - current_phase  # spec / test / impl / verify
      - quality_metrics
    location: task_context
```

---

## 最小互通矩陣

定義「開發到什麼程度」可以開始互通：

### Level 0：獨立運作

每個模組可以獨立運作，不需要其他模組。

| 模組 | 最小功能 | 可獨立完成 |
|------|----------|-----------|
| 核心 | Main Agent + 1 SubAgent | 基本任務分派 |
| 驗證 | 靜態分析 (tsc/eslint) | 基本代碼檢查 |
| 記憶 | 記憶儲存/檢索 | 基本記憶功能 |
| 觀測 | Token 計數 | 基本使用追蹤 |
| 方法論 | Spec 生成 | 基本規格輸出 |

---

### Level 1：單向通知

一個模組可以「通知」另一個模組，但不需要回應。

```
┌──────────┐  task_complete   ┌──────────┐
│   核心   │ ───────────────▶ │   驗證   │
└──────────┘                  └──────────┘
     │
     │  task_complete         ┌──────────┐
     └──────────────────────▶ │   記憶   │
                              └──────────┘
```

**需要開發**：
- 核心：PostToolUse hook 發出事件
- 驗證/記憶：接收事件的 handler

---

### Level 2：雙向查詢

模組之間可以查詢對方的資料。

```
┌──────────┐  query_memories  ┌──────────┐
│   核心   │ ◀───────────────▶│   記憶   │
└──────────┘                  └──────────┘
     │
     │  query_budget          ┌──────────┐
     └───────────────────────▶│   觀測   │
                              └──────────┘
```

**需要開發**：
- 標準化的查詢 API（透過腳本）
- 回應格式定義

---

### Level 3：協調決策

模組之間可以影響彼此的行為。

```
┌──────────┐                  ┌──────────┐
│   核心   │◀─ budget_warning ─│   觀測   │
└──────────┘                  └──────────┘
     │
     │  reduce_parallelism
     ▼
   決定減少並行 Agent 數量
```

**需要開發**：
- 跨模組的決策協議
- 優先級衝突解決

---

## 開發階段路線圖

### Phase 1：基礎骨架（垂直開發）

```
Week 1-2
┌─────────────────────────────────────────────────────────────┐
│                      必須按順序完成                          │
│                                                             │
│  Day 1-2: CLAUDE.md + plugin.json                           │
│      ↓                                                      │
│  Day 3-4: hooks.json 框架 + init-runtime.sh                 │
│      ↓                                                      │
│  Day 5-6: Main Agent + Developer Agent                      │
│      ↓                                                      │
│  Day 7-8: task-decomposition skill (基本版)                 │
│      ↓                                                      │
│  Day 9-10: state-management skill + checkpoint scripts      │
│                                                             │
│  ✓ 結果：可以執行基本的「分派任務 → 執行 → 保存狀態」流程   │
└─────────────────────────────────────────────────────────────┘
```

**驗收標準**：
```bash
# 可以運行這個流程
User: "修改 config.ts 增加一個設定項"
Main Agent: 分析 → 委派給 Developer
Developer: 執行修改
System: 保存 checkpoint
```

---

### Phase 2：平行擴展（水平開發）

```
Week 3-6（四個模組可同時開發）
┌──────────────┬──────────────┬──────────────┬──────────────┐
│   驗證模組    │   記憶模組    │   觀測模組    │  方法論模組   │
│              │              │              │              │
│ W3: 靜態分析 │ W3: 儲存     │ W3: 計數     │ W3: Spec生成 │
│ W4: 單元測試 │ W4: 檢索     │ W4: 日誌     │ W4: 健康檢查 │
│ W5: LLM Judge│ W5: 注入     │ W5: 預算警報 │ W5: 熵指標   │
│ W6: 整合     │ W6: 固化     │ W6: 報告     │ W6: 整合     │
└──────────────┴──────────────┴──────────────┴──────────────┘
```

**每週互通檢查點**：
- W3 末：Level 0 互通（各自獨立運作）
- W4 末：Level 1 互通（單向通知）
- W5 末：Level 2 互通（雙向查詢）
- W6 末：Level 3 互通（協調決策）

---

### Phase 3：深度整合（收斂開發）

```
Week 7-8
┌─────────────────────────────────────────────────────────────┐
│                      整合與優化                              │
│                                                             │
│  • 跨模組的錯誤處理                                         │
│  • 效能調優（減少重複 context 載入）                         │
│  • 邊界案例處理                                             │
│  • 完整的 E2E 測試                                          │
└─────────────────────────────────────────────────────────────┘
```

---

## 功能互通效果表

### 開發進度 vs 互通效果

| 核心 | 驗證 | 記憶 | 觀測 | 方法論 | 達成的互通效果 |
|:----:|:----:|:----:|:----:|:------:|---------------|
| ✓ | - | - | - | - | 基本任務分派 |
| ✓ | L0 | - | - | - | 任務完成後自動檢查 |
| ✓ | - | L0 | - | - | 任務開始時注入記憶 |
| ✓ | - | - | L0 | - | 追蹤 token 使用 |
| ✓ | - | - | - | L0 | 任務前生成 spec |
| ✓ | L0 | L0 | - | - | 驗證失敗記錄到記憶 |
| ✓ | - | L0 | L0 | - | 預算不足時減少記憶注入 |
| ✓ | L1 | L1 | L1 | - | 完整的任務生命週期追蹤 |
| ✓ | L1 | L1 | L1 | L1 | SDD 流程 + 品質保證 |
| ✓ | L2 | L2 | L2 | L2 | 智能決策（根據歷史調整） |
| ✓ | L3 | L3 | L3 | L3 | 全自動協調優化 |

---

## 具體互通範例

### 範例 1：驗證 + 記憶

```yaml
# 當驗證失敗時
trigger: verification_failed
flow:
  1. 驗證模組輸出失敗報告
  2. 記憶模組提取「為什麼失敗」
  3. 記憶模組儲存：
     type: episodic
     content: "在 auth.ts 使用 async/await 時忘記處理 rejection"
     tags: [async, error-handling, auth]
  4. 下次遇到類似任務時，記憶會被注入
```

**需要的開發**：
- 驗證模組：輸出結構化的失敗報告
- 記憶模組：PostToolUse hook 監聽驗證結果

---

### 範例 2：觀測 + 核心

```yaml
# 當預算緊張時
trigger: budget_at_70_percent
flow:
  1. 觀測模組發出警告
  2. 核心收到警告
  3. 核心調整策略：
     - 減少並行 Agent 數量
     - 切換到 Haiku 模型
     - 簡化驗證層級
```

**需要的開發**：
- 觀測模組：持續追蹤 + 閾值警報
- 核心：接收警報 + 調整行為的 hook

---

### 範例 3：方法論 + 驗證 + 記憶

```yaml
# SDD 完整流程
trigger: user_requests_feature
flow:
  1. 方法論模組：生成 spec.yaml
  2. 記憶模組：注入相關的過往經驗
  3. 核心：根據 spec 分派任務
  4. Developer：實作
  5. 驗證模組：執行測試
  6. 驗證失敗 → 記憶模組記錄
  7. 驗證成功 → 方法論模組更新健康指標
```

**需要的開發**：
- 方法論：spec 輸出格式
- 記憶：檢索相關經驗的 query
- 驗證：對應 spec 的測試生成

---

## 開發優先級建議

### 高 ROI（優先開發）

| 功能 | ROI 原因 |
|------|----------|
| Main Agent 路由 | 沒有它就沒有多 Agent |
| 基本 Checkpoint | 沒有它就無法恢復 |
| 靜態分析驗證 | 成本最低的品質保證 |
| Token 計數 | 防止預算爆掉 |

### 中 ROI（次優先）

| 功能 | ROI 原因 |
|------|----------|
| 記憶儲存/檢索 | 避免重複錯誤 |
| Spec 生成 | 提高需求清晰度 |
| 操作日誌 | 除錯必備 |

### 低 ROI（最後開發）

| 功能 | ROI 原因 |
|------|----------|
| LLM Judge | 成本高 |
| 熵指標 | 進階優化 |
| 複雜的記憶固化 | 需要大量資料驗證 |

---

## 總結

### 垂直組件（必須按序）

```
CLAUDE.md → Hooks 框架 → Main Agent → SubAgents → Task Skill
                ↓
        State Management → Checkpoint
```

### 平行組件（可同時開發）

```
┌──────────┬──────────┬──────────┬──────────┐
│  驗證    │   記憶   │   觀測   │  方法論  │
└──────────┴──────────┴──────────┴──────────┘
```

### 互通公式

```
核心 + 任一平行模組 = 基本加成
核心 + 兩個平行模組 = 中等加成（開始有協調效果）
核心 + 全部模組 = 完整系統
```

### 開發建議

1. **先花 2 週完成垂直骨架**
2. **然後 4 個模組平行開發**
3. **每週檢查互通點是否對齊**
4. **最後 2 週做深度整合**
