<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>打磚塊遊戲</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }

        .game-container {
            position: relative;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            padding: 20px;
        }

        canvas {
            display: block;
            background: linear-gradient(to bottom, #f0f0f0, #e8e8e8);
            border: 3px solid #333;
            cursor: none;
        }

        .info-panel {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        .info-item {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .info-label {
            color: #666;
        }

        .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 4px;
            z-index: 100;
        }

        .game-over-screen.show {
            display: flex;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 8px;
            text-align: center;
        }

        .game-over-content h1 {
            font-size: 48px;
            margin-bottom: 20px;
            color: #333;
        }

        .game-over-content .score {
            font-size: 32px;
            color: #667eea;
            margin-bottom: 30px;
        }

        .game-over-content button {
            padding: 12px 30px;
            font-size: 18px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .game-over-content button:hover {
            background: #764ba2;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <canvas id="gameCanvas" width="600" height="500"></canvas>
        <div class="info-panel">
            <div class="info-item">
                <span class="info-label">分數：</span>
                <span id="score">0</span>
            </div>
            <div class="info-item">
                <span class="info-label">命數：</span>
                <span id="lives">3</span>
            </div>
            <div class="info-item">
                <span class="info-label">關卡：</span>
                <span id="level">1</span>
            </div>
            <div class="info-item">
                <span class="info-label">磚塊數：</span>
                <span id="brickCount">80</span>
            </div>
        </div>

        <div class="game-over-screen" id="gameOverScreen">
            <div class="game-over-content">
                <h1 id="gameOverTitle">遊戲結束</h1>
                <div class="score">最終分數：<span id="finalScore">0</span></div>
                <button onclick="location.reload()">重新開始</button>
            </div>
        </div>
    </div>

    <script>
        // ============================================================
        // 遊戲常數
        // ============================================================
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 500;
        const PADDLE_WIDTH = 80;
        const PADDLE_HEIGHT = 12;
        const PADDLE_SPEED = 6;
        const BALL_RADIUS = 5;
        const BALL_SPEED = 3;
        const BRICK_WIDTH = 60;
        const BRICK_HEIGHT = 15;
        const BRICK_COLS = 10;
        const BRICK_ROWS = 8;
        const BRICK_TOP_OFFSET = 30;
        const BRICK_LEFT_OFFSET = 20;

        // 彩色磚塊顏色（彩虹順序）
        const BRICK_COLORS = [
            '#FF0000', // 紅
            '#FF7F00', // 橙
            '#FFFF00', // 黃
            '#00FF00', // 綠
            '#0000FF', // 藍
            '#4B0082', // 靛
            '#9400D3', // 紫
            '#FF1493'  // 深粉紅
        ];

        // 分數設定（不同顏色分數不同）
        const BRICK_SCORES = [10, 20, 30, 40, 50, 60, 70, 80];

        // ============================================================
        // 磚塊物件
        // ============================================================
        class Brick {
            constructor(x, y, colorIndex) {
                this.x = x;
                this.y = y;
                this.width = BRICK_WIDTH;
                this.height = BRICK_HEIGHT;
                this.colorIndex = colorIndex;
                this.color = BRICK_COLORS[colorIndex];
                this.score = BRICK_SCORES[colorIndex];
                this.active = true;
            }

            draw(ctx) {
                if (!this.active) return;

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // 邊框
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // ============================================================
        // 球物件
        // ============================================================
        class Ball {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = BALL_RADIUS;
                this.vx = BALL_SPEED * (Math.random() > 0.5 ? 1 : -1);
                this.vy = -BALL_SPEED;
                this.speed = BALL_SPEED;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
            }

            draw(ctx) {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ============================================================
        // 擋板物件
        // ============================================================
        class Paddle {
            constructor() {
                this.width = PADDLE_WIDTH;
                this.height = PADDLE_HEIGHT;
                this.x = (CANVAS_WIDTH - this.width) / 2;
                this.y = CANVAS_HEIGHT - 20;
                this.speed = PADDLE_SPEED;
            }

            moveLeft() {
                if (this.x > 0) {
                    this.x -= this.speed;
                }
            }

            moveRight() {
                if (this.x + this.width < CANVAS_WIDTH) {
                    this.x += this.speed;
                }
            }

            setPosition(mouseX) {
                this.x = mouseX - this.width / 2;
                if (this.x < 0) this.x = 0;
                if (this.x + this.width > CANVAS_WIDTH) {
                    this.x = CANVAS_WIDTH - this.width;
                }
            }

            draw(ctx) {
                ctx.fillStyle = '#667eea';
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, this.width, this.height);
            }
        }

        // ============================================================
        // 主遊戲類
        // ============================================================
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.gameOverScreen = document.getElementById('gameOverScreen');

                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }

            init() {
                this.score = 0;
                this.lives = 3;
                this.level = 1;
                this.gameOver = false;
                this.gameWon = false;
                this.paddle = new Paddle();
                this.ball = new Ball(CANVAS_WIDTH / 2, CANVAS_HEIGHT - 40);
                this.ballLaunched = false;
                this.bricks = [];
                this.createBricks();
                this.mouseX = CANVAS_WIDTH / 2;

                this.updateUI();
            }

            createBricks() {
                this.bricks = [];
                for (let row = 0; row < BRICK_ROWS; row++) {
                    for (let col = 0; col < BRICK_COLS; col++) {
                        const colorIndex = col % BRICK_COLORS.length;
                        const x = BRICK_LEFT_OFFSET + col * (BRICK_WIDTH + 5);
                        const y = BRICK_TOP_OFFSET + row * (BRICK_HEIGHT + 5);
                        this.bricks.push(new Brick(x, y, colorIndex));
                    }
                }
            }

            setupEventListeners() {
                document.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouseX = e.clientX - rect.left;
                    this.paddle.setPosition(this.mouseX);
                });

                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    this.mouseX = touch.clientX - rect.left;
                    this.paddle.setPosition(this.mouseX);
                }, { passive: false });

                document.addEventListener('click', () => {
                    if (!this.ballLaunched && !this.gameOver) {
                        this.launchBall();
                    }
                });

                document.addEventListener('touchstart', () => {
                    if (!this.ballLaunched && !this.gameOver) {
                        this.launchBall();
                    }
                });
            }

            launchBall() {
                this.ballLaunched = true;
                this.ball.vx = BALL_SPEED * (Math.random() > 0.5 ? 1 : -1) * 0.8;
                this.ball.vy = -BALL_SPEED;
            }

            update() {
                if (this.gameOver) return;

                if (this.ballLaunched) {
                    this.ball.update();
                    this.checkCollisions();
                }

                // 將球放在擋板上（未發射時）
                if (!this.ballLaunched) {
                    this.ball.x = this.paddle.x + this.paddle.width / 2;
                    this.ball.y = this.paddle.y - this.ball.radius;
                }
            }

            checkCollisions() {
                const ball = this.ball;

                // 上牆反彈
                if (ball.y - ball.radius <= 0) {
                    ball.vy = -ball.vy;
                    ball.y = ball.radius;
                }

                // 左牆反彈
                if (ball.x - ball.radius <= 0) {
                    ball.vx = -ball.vx;
                    ball.x = ball.radius;
                }

                // 右牆反彈
                if (ball.x + ball.radius >= CANVAS_WIDTH) {
                    ball.vx = -ball.vx;
                    ball.x = CANVAS_WIDTH - ball.radius;
                }

                // 底部失敗
                if (ball.y - ball.radius > CANVAS_HEIGHT) {
                    this.lives--;
                    if (this.lives <= 0) {
                        this.endGame(false);
                    } else {
                        this.ballLaunched = false;
                        this.ball = new Ball(this.paddle.x + this.paddle.width / 2,
                                            CANVAS_HEIGHT - 40);
                    }
                    this.updateUI();
                    return;
                }

                // 擋板反彈
                if (ball.y + ball.radius >= this.paddle.y &&
                    ball.x >= this.paddle.x &&
                    ball.x <= this.paddle.x + this.paddle.width) {
                    ball.vy = -ball.vy;
                    ball.y = this.paddle.y - ball.radius;

                    // 根據碰撞位置改變水平速度
                    const paddleCenter = this.paddle.x + this.paddle.width / 2;
                    const hitPos = (ball.x - paddleCenter) / (this.paddle.width / 2);
                    ball.vx = hitPos * this.ball.speed * 1.5;
                }

                // 磚塊碰撞
                for (let brick of this.bricks) {
                    if (!brick.active) continue;

                    if (ball.x + ball.radius > brick.x &&
                        ball.x - ball.radius < brick.x + brick.width &&
                        ball.y + ball.radius > brick.y &&
                        ball.y - ball.radius < brick.y + brick.height) {

                        brick.active = false;
                        this.score += brick.score;

                        // 簡化反彈邏輯：檢查碰撞方向
                        const overlapLeft = (ball.x + ball.radius) - brick.x;
                        const overlapRight = (brick.x + brick.width) - (ball.x - ball.radius);
                        const overlapTop = (ball.y + ball.radius) - brick.y;
                        const overlapBottom = (brick.y + brick.height) - (ball.y - ball.radius);

                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapLeft || minOverlap === overlapRight) {
                            ball.vx = -ball.vx;
                        } else {
                            ball.vy = -ball.vy;
                        }

                        this.updateUI();
                        break;
                    }
                }

                // 檢查勝利條件
                const activeBricks = this.bricks.filter(b => b.active).length;
                if (activeBricks === 0) {
                    this.endGame(true);
                }
            }

            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('lives').textContent = this.lives;
                document.getElementById('level').textContent = this.level;
                const activeBricks = this.bricks.filter(b => b.active).length;
                document.getElementById('brickCount').textContent = activeBricks;
            }

            endGame(won) {
                this.gameOver = true;
                const title = document.getElementById('gameOverTitle');
                const finalScore = document.getElementById('finalScore');

                if (won) {
                    title.textContent = `恭喜！第 ${this.level} 關勝利！`;
                    this.level++;
                } else {
                    title.textContent = '遊戲結束';
                }

                finalScore.textContent = this.score;
                this.gameOverScreen.classList.add('show');
            }

            draw() {
                const ctx = this.ctx;

                // 清空畫布
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // 繪製所有元素
                for (let brick of this.bricks) {
                    brick.draw(ctx);
                }

                this.paddle.draw(ctx);
                this.ball.draw(ctx);

                // 未發射時顯示提示
                if (!this.ballLaunched && !this.gameOver) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('點擊或觸控開始遊戲', CANVAS_WIDTH / 2, CANVAS_HEIGHT - 50);
                }
            }

            gameLoop = () => {
                this.update();
                this.draw();
                requestAnimationFrame(this.gameLoop);
            }
        }

        // ============================================================
        // 啟動遊戲
        // ============================================================
        window.addEventListener('load', () => {
            new Game();
        });
    </script>
</body>
</html>
